<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini React - Detailed Flow Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 30px 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 40px;
            font-size: 2.2em;
        }

        .timeline {
            position: relative;
            padding: 20px 0;
        }

        .timeline::before {
            content: '';
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 4px;
            height: 100%;
            background: linear-gradient(180deg, #667eea, #764ba2);
        }

        .timeline-item {
            margin-bottom: 50px;
            position: relative;
        }

        .timeline-item:nth-child(odd) .content {
            margin-left: 0;
            margin-right: 52%;
            text-align: right;
        }

        .timeline-item:nth-child(even) .content {
            margin-left: 52%;
            margin-right: 0;
            text-align: left;
        }

        .timeline-item::before {
            content: '';
            position: absolute;
            left: 50%;
            top: 20px;
            transform: translateX(-50%);
            width: 20px;
            height: 20px;
            background: white;
            border: 4px solid #667eea;
            border-radius: 50%;
            z-index: 1;
        }

        .content {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .timeline-item:nth-child(even) .content {
            border-left: none;
            border-right: 4px solid #764ba2;
        }

        .step-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }

        .step-description {
            color: #666;
            line-height: 1.6;
            margin-bottom: 12px;
        }

        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            margin-top: 10px;
            overflow-x: auto;
        }

        .memory-state {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #2196F3;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
        }

        .diagram {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
            margin-top: 15px;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.8;
            border: 2px dashed #667eea;
        }

        .section-divider {
            margin: 60px 0;
            padding: 20px;
            background: linear-gradient(90deg, #f0f0f0, #fff, #f0f0f0);
            border-top: 2px solid #667eea;
            border-bottom: 2px solid #667eea;
            text-align: center;
            color: #667eea;
            font-weight: bold;
            font-size: 1.1em;
        }

        .highlight-good {
            background: #c8e6c9;
            padding: 2px 6px;
            border-radius: 3px;
            color: #1b5e20;
        }

        .highlight-process {
            background: #fff9c4;
            padding: 2px 6px;
            border-radius: 3px;
            color: #f57f17;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 15px;
        }

        .comparison-box {
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid;
        }

        .before {
            background: #ffebee;
            border-color: #d32f2f;
        }

        .after {
            background: #e8f5e9;
            border-color: #388e3c;
        }

        .comparison-title {
            font-weight: bold;
            margin-bottom: 8px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>üîÑ Mini React - Detailed Execution Flow with Memory States</h1>

        <div class="timeline">
            <!-- Step 1 -->
            <div class="timeline-item">
                <div class="content">
                    <div class="step-title">Step 1: Page Load - Initial render() Call</div>
                    <div class="step-description">
                        The script initializes and calls render() to bootstrap the React app.
                    </div>
                    <div class="code-block">
                        // Initial state
                        currentFiber = null
                        workInProgress = null
                        hookIndex = 0
                        currentHook = null

                        render() {
                        hookIndex = 0
                        currentHook = null
                        workInProgressFiber = createFiber(Counter)
                        workInProgressFiber.alternate = null // First render
                        }
                    </div>
                    <div class="memory-state">
                        <strong>Memory After:</strong><br>
                        workInProgressFiber.type = Counter (function)<br>
                        workInProgressFiber.alternate = null<br>
                        workInProgressFiber.momoizedState = null
                    </div>
                </div>
            </div>

            <!-- Step 2 -->
            <div class="timeline-item">
                <div class="content">
                    <div class="step-title">Step 2: Component Execution - Counter() Called</div>
                    <div class="step-description">
                        The Counter component function is invoked. This triggers the hooks.
                    </div>
                    <div class="code-block">
                        Counter() {
                        const [count, setCount] = useState(0)
                        useEffect(() => {...}, [])

                        return {
                        type: 'div',
                        children: [...]
                        }
                        }
                    </div>
                    <div class="diagram">
                        Counter component called<br>
                        ‚Üí useState(0) called (hookIndex=0)<br>
                        ‚Üí useEffect(...) called (hookIndex=1)<br>
                        ‚Üí VDOM returned
                    </div>
                </div>
            </div>

            <!-- Step 3 -->
            <div class="timeline-item">
                <div class="content">
                    <div class="step-title">Step 3: First useState Hook Execution</div>
                    <div class="step-description">
                        <span class="highlight-good">useState(0)</span> is called for the first time. Since there's no
                        alternate fiber (first render), it creates a new hook with initial value.
                    </div>
                    <div class="code-block">
                        useState(0) {
                        let oldHook = currentFiber?.alternate?.momoizedState?.[0]
                        // oldHook = null (first render, no alternate)

                        let hook = {
                        state: 0, // Use initialValue
                        queue: [],
                        next: null
                        }

                        // Attach to linked list
                        if (hookIndex === 0) {
                        workInProgressFiber.momoizedState = hook
                        }

                        currentHook = hook
                        hookIndex++ // Now 1

                        return [0, setState]
                        }
                    </div>
                    <div class="memory-state">
                        <strong>Memory Snapshot:</strong><br>
                        workInProgressFiber.momoizedState ‚Üí hook1 {state: 0, queue: []}<br>
                        currentHook = hook1<br>
                        hookIndex = 1
                    </div>
                </div>
            </div>

            <!-- Step 4 -->
            <div class="timeline-item">
                <div class="content">
                    <div class="step-title">Step 4: useEffect Hook Registration</div>
                    <div class="step-description">
                        The effect hook is registered. Since this is the first render, there's no old effect to compare
                        dependencies against, so hasChanged defaults to true.
                    </div>
                    <div class="code-block">
                        useEffect(() => {
                        console.log("Effect Runs")
                        return () => console.log("CleanUp")
                        }, []) {
                        let oldEffect = null // First render
                        let hasChanged = true // No deps to compare

                        let effect = {
                        callback: () => {...},
                        deps: [],
                        cleanUp: null,
                        hasChanged: true
                        }

                        workInProgressFiber.updateQueue.push(effect)
                        hookIndex++ // Now 2
                        }
                    </div>
                    <div class="memory-state">
                        <strong>Memory Snapshot:</strong><br>
                        workInProgressFiber.updateQueue[0] = {callback, deps: [], cleanUp: null, hasChanged: true}<br>
                        hookIndex = 2
                    </div>
                </div>
            </div>

            <!-- Step 5 -->
            <div class="timeline-item">
                <div class="content">
                    <div class="step-title">Step 5: Commit Phase - DOM Creation</div>
                    <div class="step-description">
                        Since <span class="highlight-process">workInProgressFiber.dom is null</span> (first render),
                        commitDOM creates actual DOM elements from the VDOM.
                    </div>
                    <div class="code-block">
                        commitDOM(vdom) {
                        if (!workInProgressFiber.dom) {
                        // First render: create all elements
                        const container = document.createElement("div")

                        // Create h2 with "Count: 0"
                        const h2 = document.createElement("h2")
                        h2.textContent = "Count: 0"
                        container.appendChild(h2)

                        // Create button with onClick
                        const button = document.createElement("button")
                        button.textContent = "increment"
                        button.onClick = () => setCount(c => c + 1)
                        container.appendChild(button)

                        rootDOM.appendChild(container)
                        workInProgressFiber.dom = container
                        }
                        }
                    </div>
                    <div class="diagram">
                        <strong>DOM Structure Created:</strong><br>
                        &lt;div id="root"&gt;<br>
                        &nbsp;&nbsp;&lt;div&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&lt;h2&gt;Count: 0&lt;/h2&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&lt;button&gt;increment&lt;/button&gt;<br>
                        &nbsp;&nbsp;&lt;/div&gt;<br>
                        &lt;/div&gt;
                    </div>
                </div>
            </div>

            <!-- Step 6 -->
            <div class="timeline-item">
                <div class="content">
                    <div class="step-title">Step 6: Effect Execution Phase</div>
                    <div class="step-description">
                        Since hasChanged is true for the effect, the callback is executed and its return value (cleanup
                        function) is stored.
                    </div>
                    <div class="code-block">
                        runEffects() {
                        workInProgressFiber.updateQueue.forEach((effect) => {
                        if (effect.hasChanged) {
                        // First render: cleanUp is null
                        if (effect.cleanUp) effect.cleanUp()

                        // Execute effect callback
                        effect.cleanUp = effect.callback()
                        // effect.cleanUp now = () => console.log("CleanUp")
                        }
                        })
                        }
                    </div>
                    <div class="memory-state">
                        <strong>Console Output:</strong><br>
                        "Effect Runs :count=0"<br><br>
                        <strong>Memory Update:</strong><br>
                        workInProgressFiber.updateQueue[0].cleanUp = cleanup function
                    </div>
                </div>
            </div>

            <!-- Step 7 -->
            <div class="timeline-item">
                <div class="content">
                    <div class="step-title">Step 7: Finalize First Render</div>
                    <div class="step-description">
                        The render cycle completes. The workInProgressFiber becomes the current fiber for the next
                        cycle.
                    </div>
                    <div class="code-block">
                        currentFiber = workInProgressFiber

                        // End of first render cycle
                        // State at this point:
                        // currentFiber: has momoizedState with hook1 (count=0)
                        // currentFiber: has updateQueue with effect (cleanUp stored)
                        // currentFiber: has dom pointing to actual DOM elements
                    </div>
                    <div class="memory-state">
                        <strong>Final State After Initial Render:</strong><br>
                        currentFiber.type = Counter<br>
                        currentFiber.momoizedState = hook1 {state: 0, queue: []}<br>
                        currentFiber.updateQueue[0] = {callback, deps: [], cleanUp: cleanup_fn, hasChanged: true}<br>
                        currentFiber.dom = actual DOM container<br>
                        currentFiber.alternate = null
                    </div>
                </div>
            </div>

            <div class="section-divider">‚ö° USER INTERACTION: Click Increment Button ‚ö°</div>

            <!-- Step 8 -->
            <div class="timeline-item">
                <div class="content">
                    <div class="step-title">Step 8: Button Click Event Fired</div>
                    <div class="step-description">
                        The user clicks the increment button. The onClick handler is triggered, calling setState with an
                        updater function.
                    </div>
                    <div class="code-block">
                        // User clicks button
                        button.onClick triggered

                        // setState is called with updater function
                        setState(c => c + 1) {
                        hook.queue.push(
                        typeof action === "function" ? action : () => action
                        )
                        // hook.queue = [(c) => c + 1]

                        scheduleUpdate()
                        }
                    </div>
                    <div class="memory-state">
                        <strong>Memory Change:</strong><br>
                        currentFiber.momoizedState.queue = [(c) => c + 1]<br>
                        <strong>State:</strong> count still = 0 (update queued, not applied yet)
                    </div>
                </div>
            </div>

            <!-- Step 9 -->
            <div class="timeline-item">
                <div class="content">
                    <div class="step-title">Step 9: Second Render Cycle - Initialization</div>
                    <div class="step-description">
                        scheduleUpdate() calls render() again. A new fiber is created, and the old fiber becomes its
                        alternate.
                    </div>
                    <div class="code-block">
                        render() {
                        hookIndex = 0
                        currentHook = null

                        workInProgressFiber = createFiber(Counter)
                        // Link to previous fiber
                        workInProgressFiber.alternate = currentFiber
                        // Now we have access to old state!

                        const vdom = Counter()
                        }
                    </div>
                    <div class="memory-state">
                        <strong>Before Counter() call:</strong><br>
                        workInProgressFiber.alternate = currentFiber<br>
                        workInProgressFiber.alternate.momoizedState.queue = [(c) => c + 1]<br>
                        workInProgressFiber.momoizedState = null (fresh fiber)
                    </div>
                </div>
            </div>

            <!-- Step 10 -->
            <div class="timeline-item">
                <div class="content">
                    <div class="step-title">Step 10: useState - Retrieve Old Hook & Apply Updates</div>
                    <div class="step-description">
                        useState is called again. This time it finds the old hook from the alternate fiber and applies
                        all queued updates.
                    </div>
                    <div class="code-block">
                        useState(0) {
                        // Get old hook from alternate
                        let oldHook = currentFiber?.alternate?.momoizedState?.next?.[0]
                        // oldHook = {state: 0, queue: [(c) => c + 1], next: null}

                        let hook = {
                        state: oldHook.state, // Start with old state: 0
                        queue: [], // Fresh queue for next update
                        next: null
                        }

                        // Apply all queued updates
                        oldHook.queue.forEach((update) => {
                        hook.state = update(hook.state)
                        // Iteration 1: hook.state = (c => c + 1)(0) = 1
                        })

                        return [1, setState] // Returns NEW state!
                        }
                    </div>
                    <div class="comparison-grid">
                        <div class="comparison-box before">
                            <div class="comparison-title">‚ùå Before Apply</div>
                            hook.state = 0<br>
                            hook.queue = [(c) => c + 1]
                        </div>
                        <div class="comparison-box after">
                            <div class="comparison-title">‚úÖ After Apply</div>
                            hook.state = 1<br>
                            hook.queue = []
                        </div>
                    </div>
                </div>
            </div>

            <!-- Step 11 -->
            <div class="timeline-item">
                <div class="content">
                    <div class="step-title">Step 11: useEffect - Dependency Check</div>
                    <div class="step-description">
                        useEffect retrieves the old effect and checks if dependencies changed. Since deps = [] (always
                        same), hasChanged = false.
                    </div>
                    <div class="code-block">
                        useEffect(() => {...}, []) {
                        // Get old effect from alternate
                        let oldEffect = currentFiber.alternate.updateQueue[0]
                        // oldEffect = {callback, deps: [], cleanUp: cleanup_fn, hasChanged: true}

                        // Check if deps changed
                        let hasChanged = deps.some((d, i) => d !== oldEffect.deps[i])
                        // [].some(...) = false

                        let effect = {
                        callback: () => {...},
                        deps: [],
                        cleanUp: oldEffect.cleanUp, // Preserve old cleanup
                        hasChanged: false // Don't re-run!
                        }

                        workInProgressFiber.updateQueue.push(effect)
                        }
                    </div>
                    <div class="memory-state">
                        <strong>Key Insight:</strong><br>
                        Because deps = [], the effect won't run again<br>
                        The old cleanup function is preserved<br>
                        hasChanged = false prevents re-execution
                    </div>
                </div>
            </div>

            <!-- Step 12 -->
            <div class="timeline-item">
                <div class="content">
                    <div class="step-title">Step 12: Component Returns New VDOM</div>
                    <div class="step-description">
                        Counter component now has count = 1, so it returns updated VDOM with "Count: 1".
                    </div>
                    <div class="code-block">
                        Counter() {
                        const [count, setCount] = useState(0) // Returns [1, setState]
                        useEffect(() => {...}, [])

                        return {
                        type: 'div',
                        children: [{
                        type: 'h2',
                        text: "Count: " + count, // "Count: 1"
                        }, {
                        type: 'button',
                        text: "increment",
                        onClick: () => setCount(c => c + 1)
                        }]
                        }
                        }
                    </div>
                    <div class="diagram">
                        <strong>VDOM Update:</strong><br>
                        children[0].text changed from "Count: 0" ‚Üí "Count: 1"<br>
                        children[1] unchanged
                    </div>
                </div>
            </div>

            <!-- Step 13 -->
            <div class="timeline-item">
                <div class="content">
                    <div class="step-title">Step 13: Commit Phase - Efficient DOM Update</div>
                    <div class="step-description">
                        Since <span class="highlight-process">workInProgressFiber.dom already exists</span> (second
                        render), only the changed h2 element is updated, NOT the entire DOM recreated.
                    </div>
                    <div class="code-block">
                        commitDOM(vdom) {
                        if (!workInProgressFiber.dom) {
                        // ... skip (dom exists from previous render)
                        } else {
                        // Second+ render: only update changed elements
                        const h2 = workInProgressFiber.dom.querySelector("h2")
                        h2.textContent = vdom.children[0].text // "Count: 1"
                        }
                        }
                    </div>
                    <div class="comparison-grid">
                        <div class="comparison-box before">
                            <div class="comparison-title">DOM Before Click</div>
                            &lt;h2&gt;Count: 0&lt;/h2&gt;
                        </div>
                        <div class="comparison-box after">
                            <div class="comparison-title">DOM After Click</div>
                            &lt;h2&gt;Count: 1&lt;/h2&gt;
                        </div>
                    </div>
                </div>
            </div>

            <!-- Step 14 -->
            <div class="timeline-item">
                <div class="content">
                    <div class="step-title">Step 14: Effect Phase - No Execution</div>
                    <div class="step-description">
                        runEffects checks each effect. Since hasChanged = false (deps didn't change), the callback is
                        NOT executed.
                    </div>
                    <div class="code-block">
                        runEffects() {
                        workInProgressFiber.updateQueue.forEach((effect) => {
                        if (effect.hasChanged) { // false!
                        // SKIPPED: Don't run callback
                        // SKIPPED: Don't call cleanup
                        }
                        })
                        }
                    </div>
                    <div class="memory-state">
                        <strong>Console Output:</strong><br>
                        (nothing - effect doesn't re-run)
                    </div>
                </div>
            </div>

            <!-- Step 15 -->
            <div class="timeline-item">
                <div class="content">
                    <div class="step-title">Step 15: Complete Second Render Cycle</div>
                    <div class="step-description">
                        The second render cycle finishes. The workInProgressFiber becomes the new currentFiber.
                    </div>
                    <div class="code-block">
                        currentFiber = workInProgressFiber

                        // Ready for next cycle
                        // Next state:
                        // currentFiber.momoizedState.state = 1 (updated!)
                        // currentFiber.momoizedState.queue = [] (cleared!)
                        // currentFiber.updateQueue[0].hasChanged = false
                    </div>
                    <div class="memory-state">
                        <strong>Final State After Re-render:</strong><br>
                        currentFiber.momoizedState = hook {state: 1, queue: []}<br>
                        currentFiber.dom = same DOM container (h2 text updated)<br>
                        currentFiber.alternate = old fiber (from previous render)
                    </div>
                </div>
            </div>

            <!-- Step 16 -->
            <div class="timeline-item">
                <div class="content">
                    <div class="step-title">Step 16: User Sees Updated UI</div>
                    <div class="step-description">
                        The browser displays the updated count. The component is ready for the next interaction.
                    </div>
                    <div class="code-block">
                        // Browser renders updated DOM
                        // User sees: "Count: 1" and increment button
                        // User can click again to increment to 2, 3, etc.
                    </div>
                    <div class="diagram">
                        <strong>UI Display:</strong><br>
                        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê<br>
                        ‚îÇ Count: 1 ‚îÇ<br>
                        ‚îÇ [increment] ‚îÇ<br>
                        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò<br><br>
                        Ready for next click!
                    </div>
                </div>
            </div>
        </div>

        <div class="section-divider">üìä Key Concepts Summary</div>

        <div style="margin-top: 30px;">
            <div
                style="background: #f0f7ff; padding: 25px; border-radius: 8px; border-left: 4px solid #2196F3; margin-bottom: 20px;">
                <h3 style="color: #1976D2; margin-bottom: 15px;">üéØ The Fiber Architecture</h3>
                <p style="line-height: 1.8; color: #333;">
                    React uses a <strong>two-fiber system</strong>: currentFiber (stable) and workInProgressFiber (being
                    built).
                    The alternate reference links them, allowing the new fiber to access state from the old one. This
                    enables
                    efficient updates without losing context between renders.
                </p>
            </div>

            <div
                style="background: #f3e5f5; padding: 25px; border-radius: 8px; border-left: 4px solid #9C27B0; margin-bottom: 20px;">
                <h3 style="color: #6A1B9A; margin-bottom: 15px;">üîó Hook Linked Lists</h3>
                <p style="line-height: 1.8; color: #333;">
                    Hooks are stored in a <strong>linked list</strong> on momoizedState. The first hook sits at the
                    root,
                    subsequent hooks are accessed via the next pointer. This ordering is CRITICAL‚Äîhooks must be called
                    in the same order every render, otherwise the wrong state gets used.
                </p>
            </div>

            <div
                style="background: #e8f5e9; padding: 25px; border-radius: 8px; border-left: 4px solid #388E3C; margin-bottom: 20px;">
                <h3 style="color: #1B5E20; margin-bottom: 15px;">‚öôÔ∏è State Update Queuing</h3>
                <p style="line-height: 1.8; color: #333;">
                    When setState is called, the updater function is queued, not applied immediately. During the next
                    render,
                    all queued updates are applied sequentially to the old state. This allows batching of updates and
                    ensures predictable state transitions.
                </p>
            </div>

            <div
                style="background: #fff3e0; padding: 25px; border-radius: 8px; border-left: 4px solid #F57C00; margin-bottom: 20px;">
                <h3 style="color: #E65100; margin-bottom: 15px;">üìã Effect Dependency Optimization</h3>
                <p style="line-height: 1.8; color: #333;">
                    Effects track dependencies to avoid unnecessary re-execution. The hasChanged flag determines whether
                    to run the effect. Empty dependency array [] means dependencies never change, so the effect runs
                    only once
                    on mount, and subsequent cleanups preserve their previous state.
                </p>
            </div>

            <div style="background: #fce4ec; padding: 25px; border-radius: 8px; border-left: 4px solid #C2185B;">
                <h3 style="color: #880E4F; margin-bottom: 15px;">üé≠ Three-Phase Render Cycle</h3>
                <p style="line-height: 1.8; color: #333;">
                    <strong>1. Render:</strong> Call component function, collect hooks, generate VDOM.<br>
                    <strong>2. Commit:</strong> Create/update actual DOM elements.<br>
                    <strong>3. Effects:</strong> Execute effect callbacks and cleanup functions.
                </p>
            </div>
        </div>
    </div>
</body>

</html>